# Getting Started

The entirety of the SMF is currently found within the statemachineframework package in the 2022\_CompBot repository, BUT THIS WILL BE MOVED LATER PLEASE BUG ME ABOUT THIS

## Definitions

* **Subsystem** - Every subsystem utilizing the SMF (which not all subsystems in your repository have to, only the ones that need it) is a subclass of `StatedSubsystem` class. It contains details about which **states** a subsystem can have, as well as how it can transition between states
* **State** - Different physical states a subsystem can have. They inform the rest of the code about the subsystem's current state and allow the subsystem to determine how it should move between states. They can be visualized as nodes on a graph
* **Flag state** - States that the subsystem does not actively transition into and out of. They provide more information about the subsystem's state, without creating additional complexity for transitions or transitioning between **continuous commands**
* **Transition** - When visualizing the **subsystem** as a graph, transitions are the edges of the graph. They describe a valid route between two **states**, and that route is traversed by running a **transitional command**.
* **Transitional Command** - A command that runs as a subsystem is performing a transition. The subsystem assumes that once this command has finished running, it has reached the state to which it is transitioning. These commands should ideally be short (although they don't have to be). If the command does not ever end, the **subsystem** will leave the command running and assume it is still transitioning until that transition is canceled.
* **Continuous Command** - A command that is started once a transition finishes. These commands don't _have_ to run forever (no errors will be thrown if they stop), but they are primarily meant as commands that can run indefinitely and be canceled at any time (i.e. continually adjusting the flywheel speed, hood angle, and rotation angle of a turret while it is actively tracking a target.)
* **Undetermined State** - A **state** that all subsystems must have. It is the state to which the subsystem is initialized. Being in an undetermined state indicates that the subsystem does not currently know its own state. Every **subsystem** must be able to determine itself, meaning that it can transition to a known **state** easily. This can be through blind value setting (i.e. trusting that a turret has been reset to the correct angle), although it is preferable that the **subsystem** has whatever sensors are necessary to ensure that it knows its own **state** (i.e. a turret with a hall effect sensor that can detect it is at the correct angle). The **subsystem** should determine its **state** as soon as it gets **enabled**.
* **Enabled** - Whether a **subsystem** should be actively controlling its own **state**. This is separate from enabling or disabling the robot as a whole, although the two can coincide. For instance, it would generally only make sense to enable an intake once the robot is enabled, because control of the intake's state is based solely on physical actuators (i.e. pneumatics and motors), which can only be actuated when the robot is enabled. However, something like a subsystem to manage the color of LED's could be enabled as early as the `robotInit()`method of `Robot.java` because LED values can still be changed without the robot being actively enabled.
